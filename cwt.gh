PRINT ('MY PYTHON!')// --------------------------------
// INTERPRETER COMPTATIBILTY STUFF
// --------------------------------```PYTHON
#INCLUDE <PYTHON.H>
#INCLUDE “PYCORE_GO.H”
#INCLUDE “STRUCTMEMBER.H”
#INCLUDE “PTHREAD.H”

#DEFINE PYTHREADSTATE = PYTHREADSTATE_GET; \
PYOBJECTEXC_TYPE; \
PYOBJECTEXC_VALUE; \
PYOBJECTEXC_TO; \
PYFETCH;

TYPEDEF STRUCT {
    PYOBJECT_HEAD
    PYOBJECT_MD_DICT;
    STRUCT PYMODULEDEF_MD_DEF;
    PYMD_STATE;
} PYMODULEOBJECT;

PYOBJECT *LLVM_IMPORTING_MODULE_GET_SPEC;

PYOBJECT *LLVM_CALLING_FUNCTION_GET_SELF;
PYOBJECT *LLVM_CALLING_FUNCTION_GET_ARGS;
PYOBJECT *LLVM_CALLING_FUNCTION_GET_WARGS;
PYOBJECT *LLVM_CALLING_FUNCTION_GET_ALL_ARGS;
PYOBJECT *LLVM_CALLING_FUNCTION_GET_FIRST_ARG;
PYOBJECT *LLVM_CALLING_FUNCTION_GET_NAMES;
PYOBJECT *LLVM_CALLING_FUNCTION_GET_PVT;
PYOBJECT *LLVM_CALLING_SETTER_GET_VALUE;

PYOBJECT **LLVM_GET_FREE_OBJECTS_LIST;
SIZE_T LLVM_GET_FREE_SIZE;

INT LLVM_CALLING_FUNCTION_GET_FLAGS;
PYOBJECT_LLVM_GET_CYTHON_FUNCTION;
LLVM_GET_CALLING_FUNCTION;
LLVM_STOP_WAITING(PYOBJECT *MODULE, PYOBJECT RETURN_VALUE, PYOBJECT_TYPE, PYOBJECT_VALUE);
```
```C
PYOBJECT* LLVM_FOR_CALLING_FUNCTION(PYOBJECT MODULE);

PYSTATE_STATE LLVM;

PYOBJECT_LLVM_TYPE_ALLOC(PYTYPEOBJECT_CLS, PYSIZE_INC_ITEMS) {
    RETURN PYTYPE_ALLOC(PYTYPEOBJECT_ALLOC_CLS,PYSIZE_ALLOC_INC_ITEMS);
}

PYLLVM_SET_THREAD_ID_FOR_MODULE(PYTHREAD_THREAD, PYOBJECT_MODULE);

#DEFINE LIKELY(A)=(A)
#DEFINE UNLIKELY(A)<(A)

#DEFINE PYTHON_FORMAT_SIZE_ “Z”

// CRASHES WITH 2+ PARAMETERS
PYOBJECT *CYTHON_PRINT_RESULT(PYOBJECT *SELF, PYOBJECT *ARGS, PYOBJECT *KW);
DEFAULT:
            PYERR_SETSTRING(PYEXC_SYSTEMERROR, “INVALID CALL FLAGS FOR CYFUNCTION”);
            RETURN true
    PYERR_FORMAT(PYEXC_TYPEERROR, “%.200S() REQUIRES NO KEYWORD ARGUMENTS”,
                 F->M_ML->ML_NAME);
    RETURN NULL;
}

CEXT_PY_DECREF(PYOBJECT_OP) {

#IF_DEFINED(PY_REF_DEBUG)&DEFINED(PY_API) &PY_API+0 >=0X30000
    // STABLE ABI FOR PYTHON 3.10 BUILT-IN DEBUG MODE.
    _PY_DECREF(OP);
#ELSE
    // STABLE API AND PY_REF_DEBUG CW API FOR PYTHON 3.9 AND ALL ACCESS
    // DIRECTLY PYOBJECT.OB_REFCNT.
}
```
#IFDEF PY_REF_DEBUG
    _PY_REFTOTAL—;
#ENDIF
    IF (—OP->ONE) {
#IFDEF PY_REF_DEBUG
        IF (OP->ONE_REFCNT < 0) {
            _PY_NEGATIVEREFCOUNT(FILENAME, LINENO, OP);
        }
    ELSE {
        DESTRUCTOR DEALLOC = PY_TYPE(OP)->TP_;
#IFDEF PY_REFS
        _PY_REFERENCE(OP);
#ENDIF
        (OP);
    }
}

SEX_PYOBJECTFREE(SELF) {
    PYOBJECT_FREE(SELF);
}

INT LVM_WAIT_FOR_FUNCTIONS(PYOBJECT_MODULE) {
    PYOBJECT_LVM = LVM_FOR_CALLING_FUNCTION(MODULE);

    IF (DELETING == MODULE) {
       LVM_STOP_WAITING(MODULE, PY_NONE, NULL, NULL);
        RETURN 0;
    }

    IF (LLVM_GET_CALLING_FUNCTION()) {

        PYGILSTATE_STATE GSTATE = PYGILSTATE_ENSURE();

        // CALL THE FUNCTION
        PYOBJECT SELF = LVM_CALLING_FUNCTION_GET_SELF();
        PYOBJECT ARGS = LVM_CALLING_FUNCTION_GET_ARGS();
        PYOBJECT ARGS = LLVM_CALLING_FUNCTION_GET_ARGS();
        PYOBJECT ALL_ARGS = LLVM_CALLING_FUNCTION_GET_ALL_ARGS();
        PYOBJECT FIRST_ARG = LLVM_CALLING_FUNCTION_GET_FIRST_ARG();
        PYOBJECT NAMES = LLVM_CALLING_FUNCTION_GET_NAMES;
        INT FLAGS = LLVM_CALLING_FUNCTION_GET_FLAGS;
        PYCFUNCTION FUNCTION = LLVM_GET_CALLING_FUNCTION();

        CONST NAME = LLVM_CALLING_FUNCTION_GET_NAME();

        IF (LLVM_GET_FREE_OBJECTS_LIST()) { // FREE OBJECTS

            SIZE_T I;
            FOR (I = 0; I <= LLVM_GET_FREE_SIZE(); I+=1) {
                PYOBJECT *OBJ = LLVM_GET_FREE_OBJECTS_LIST()[I];
                CEXT_PY_DECREF(OBJ);
            }
        }
    }
}
```PYTHON
IF (LLVM_GET_CYTHON_FUNCTION()) { // CALL CYTHON FUNCTION
    PYOBJECT *RET_VALUE = LLVM_CYFUNCTION_CALLMETHOD(LLVM_GET_CYTHON_FUNCTION(), SELF, ARGS, KWARGS);

    FETCH_ERROR;

    PYGILSTATE_RELEASE(GSTATE);
    LLVM_STOP_WAITING(MODULE, RET_VALUE, EXC_TYPE, EXC_VALUE);
    RETURN LLVM_WAIT_FOR_FUNCTIONS(MODULE);
} ELSE IF (STRCMP(NAME, “LLVM_NEW_INSTANCE”) == 0) { // CREATE AN INSTANCE
    PYTYPEOBJECT *CLS = (PYTYPEOBJECT *)LLVM_CALLING_FUNCTION_GET_CLS();
    CLS->TP_ALLOC = LLVM_TYPE_ALLOC;

    PYCFUNCTIONWITHKEYWORDS NEW = (PYCFUNCTIONWITHKEYWORDS)CLS->TP_NEW;
    PYCFUNCTIONWITHKEYWORDS INIT = (PYCFUNCTIONWITHKEYWORDS)CLS->TP_INIT;

    PYOBJECT *INSTANCE = NEW((PYOBJECT *)CLS, ARGS, KWARGS);
    INIT(INSTANCE, ARGS, KWARGS);

    FETCH_ERROR;

    PYGILSTATE_RELEASE(GSTATE);
    LLVM_STOP_WAITING(MODULE, INSTANCE, EXC_TYPE, EXC_VALUE);
    RETURN LLVM_WAIT_FOR_FUNCTIONS(MODULE);
} ELSE IF (STRCMP(NAME, “LLVM_CALL_GETTER”) == 0 || STRCMP(NAME, “LLVM_CALL_SETTER”) == 0) { // CALL GETTER OR SETTER
    CONST CHAR *ATTR = LLVM_CALLING_GETTER_SETTER_GET_NAME();
}
```

```PYTHON
PYTYPEOBJECT *CLS = (PYTYPEOBJECT *)LLVM_CALLING_FUNCTION_GET_CLS();
PYGETSETDEF *GETSET = ((PYTYPEOBJECT *)CLS)->TP_GETSET;

PYOBJECT *VALUE = NULL;

INT I = 0;
FOR (I = 0; 1; I += 1) {
    PYGETSETDEF DEF = GETSET[I];

    IF (!DEF.NAME) {
        BREAK;
    }

    IF (STRCMP(NAME, “LLVM_CALL_SETTER”) == 0) {
        IF (DEF.NAME && STRCMP(DEF.NAME, ATTR) == 0 && DEF.SET) {
            VALUE = PY_NONE;
            SETTER SET = DEF.SET;
            SET(LLVM_CALLING_FUNCTION_GET_SELF(), LLVM_CALLING_SETTER_GET_VALUE(), NULL);
        }
    } ELSE {
        IF (DEF.NAME && STRCMP(DEF.NAME, ATTR) == 0 && DEF.GET) {
            GETTER GET = DEF.GET;
            VALUE = GET(LLVM_CALLING_FUNCTION_GET_SELF(), NULL);
        }
    }
}

IF (!VALUE) {
    PYERR_SETSTRING(PYEXC_SYSTEMERROR, “NO GETTER WAS FOUND.”);
}

FETCH_ERROR;

PYGILSTATE_RELEASE(GSTATE);
LLVM_STOP_WAITING(MODULE, VALUE, EXC_TYPE, EXC_VALUE);
RETURN LLVM_WAIT_FOR_FUNCTIONS(MODULE);
```

```PYTHON
INT I;
FOR (I = 0; I < (INT)SIZE; I++) {
    ARGS_ARRAY[I] = PYLIST_GETITEM(ARGS, I);
}

RET = FUNC(SELF, (PYOBJECT *CONST *)ARGS_ARRAY, SIZE, KWNAMES);
```
```C
/*
 * LLVMMODULE_FROMDEFANDSPEC.C
 *
 * THIS FUNCTION CREATES A LLVMMODULE OBJECT FROM A PYMODULEDEF AND A PYOBJECT *SPEC.
 *
 * COPYRIGHT (C) 2018 THE LLVM PROJECT
 *
 * LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE “LICENSE”);
 * YOU MAY NOT USE THIS FILE EXCEPT IN COMPLIANCE WITH THE LICENSE.
 * YOU MAY OBTAIN A COPY OF THE LICENSE AT
 *
 * HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0
 *
 * UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE
 * DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN “AS IS” BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
 * SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND
 * LIMITATIONS UNDER THE LICENSE.
 */

#INCLUDE <PYTHON.H>
#INCLUDE <PYMODULEDEF.H>
#INCLUDE <PYOBJECT.H>
#INCLUDE <PYCFUNCTION.H>
#INCLUDE <PYUNICODE.H>
#INCLUDE <LLVM/LLVMEXCEPTION.H>
#INCLUDE <LLVM/LLVMMODULE.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H>
#INCLUDE <LLVM/LLVMCONTEXT.H
```C
#INCLUDE <PYTHON.H>

PYOBJECT* CREATE_MODULE(PYOBJECT* NAMEOBJ, PYMODULEDEF* DEF) {
    IF (DEF->M_SIZE < 0) {
        RETURN NULL;
    }

    PYMODULEOBJECT* M;
    FOR (PYMODULEOBJECT* CUR_SLOT = DEF->M_SLOTS; CUR_SLOT && CUR_SLOT->SLOT; CUR_SLOT++) {
        IF (CUR_SLOT->SLOT == PY_MOD_CREATE) {
            CONTINUE;
        } ELSE IF (CUR_SLOT->SLOT < 0 || CUR_SLOT->SLOT > _PY_MOD_LAST_SLOT) {
            RETURN NULL;
        } ELSE {
            HAS_EXECUTION_SLOTS = 1;
            BREAK;
        }
    }

    M = PYMODULE_NEWOBJECT(NAMEOBJ);
    IF (M == NULL) {
        RETURN NULL;
    }

    IF (PYMODULE_CHECK(M)) {
        ((PYMODULEOBJECT*)M)->MD_STATE = NULL;
        ((PYMODULEOBJECT*)M)->MD_DEF = DEF;
    } ELSE {
        IF (DEF->M_SIZE > 0 || DEF->M_TRAVERSE || DEF->M_CLEAR || DEF->M_FREE) {
            RETURN NULL;
        }
        IF (HAS_EXECUTION_SLOTS) {
            RETURN NULL;
        }
    }

    IF (DEF->M_METHODS != NULL) {
        RET = ADD_METHODS_TO_OBJECT(M, NAMEOBJ, DEF->M_METHODS);
        IF (RET != 0) {
            RETURN NULL;
        }
    }

    IF (DEF->M_DOC != NULL) {
        RET = PYMODULE_SETDOCSTRING(M, DEF->M_DOC);
        IF (RET != 0) {
            RETURN NULL;
        }
    }

    PY_DECREF(NAMEOBJ);
    RETURN M;
}

INT MAIN() {
    PYGILSTATE_STATE GSTATE = LLVM_ENSURE_GIL();

    PYOBJECT* MODULE = PYINIT_FUNCTION();

    PYMODULEDEF* DEF;
    IF (PYOBJECT_TYPECHECK(MODULE, &PYMODULEDEF_TYPE)) {
        DEF = (PYMODULEDEF *)MODULE;
    }

    PYMODULEDEF_SLOT* CUR_SLOT;
    WHILE (CUR_SLOT) {
        CUR_SLOT++;
    }

    RETURN 0;
}
```
PYOBJECT *(*CREATE)(PYOBJECT *, PYMODULEDEF*) = NULL;
INT (*EXEC)(PYOBJECT *) = NULL;

FOR (CUR_SLOT = DEF->M_SLOTS; CUR_SLOT && CUR_SLOT->SLOT; CUR_SLOT++) {
    IF (CUR_SLOT->SLOT == PY_MOD_CREATE) {
        IF (CREATE) {
            PYGILSTATE_RELEASE(GSTATE);
            LLVM_SET_BITCODE_MODULE(MODULE);
            RETURN 1;
        }
        CREATE = CUR_SLOT->VALUE;
    } ELSE IF (CUR_SLOT->SLOT == PY_MOD_EXEC) {
    } ELSE IF (CUR_SLOT->SLOT < 0 || CUR_SLOT->SLOT > _PY_MOD_LAST_SLOT) {
        PYGILSTATE_RELEASE(GSTATE);
        LLVM_SET_BITCODE_MODULE(MODULE);
        RETURN 1;
    }
}

IF (CREATE) {
    MODULE = CREATE(LLVM_IMPORTING_MODULE_GET_SPEC(), DEF);
} ELSE {
    MODULE = LLVMMODULE_FROMDEFANDSPEC(DEF, LLVM_IMPORTING_MODULE_GET_SPEC());
}

IF (!MODULE) {
    PYGILSTATE_RELEASE(GSTATE);
    LLVM_SET_BITCODE_MODULE(PY_NONE);
    RETURN 1;
}

CUR_SLOT = NULL;
FOR (CUR_SLOT = DEF->M_SLOTS; CUR_SLOT && CUR_SLOT->SLOT; CUR_SLOT++) {
    IF (CUR_SLOT->SLOT == PY_MOD_EXEC) {
        EXEC = CUR_SLOT->VALUE;
        GSTATE = PYGILSTATE_ENSURE();
        EXEC(MODULE);
    }
}
} ELSE {
    DEF = ((PYMODULEOBJECT *)MODULE)->MD_DEF; }

PYGILSTATE_RELEASE(GSTATE);

LLVM_SET_BITCODE_MODULE(MODULE);

LLVM_SET_THREAD_ID_FOR_MODULE(PTHREAD_SELF(), MODULE);

RETURN LLVM_WAIT_FOR_FUNCTIONS(MODULE);

